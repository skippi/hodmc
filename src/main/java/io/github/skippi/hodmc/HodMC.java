/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.github.skippi.hodmc;

import net.minecraft.server.v1_16_R3.EntityLiving;
import org.bukkit.*;
import org.bukkit.craftbukkit.v1_16_R3.CraftWorld;
import org.bukkit.entity.Creature;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitScheduler;
import org.bukkit.scoreboard.Scoreboard;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

public class HodMC extends JavaPlugin {
    private Runnable ticker = this::tickDay;
    private List<Wave> waves = Arrays.asList(Wave.builder().withUnitGroup("zergling", 20).withUnitGroup("ultralisk", 5).build());
    private int roundIndex = 0;
    private long roundTime = 0;
    private List<EntityLiving> roundEntities = new ArrayList<>();

    @Override
    public void onEnable() {
        World world = getServer().getWorld("world");
        world.setFullTime(0);
        world.setGameRule(GameRule.DO_WEATHER_CYCLE, false);
        world.setGameRule(GameRule.KEEP_INVENTORY, true);
        world.setGameRule(GameRule.SPECTATORS_GENERATE_CHUNKS, false);
        world.setGameRule(GameRule.DO_MOB_SPAWNING, false);
        WorldBorder border = world.getWorldBorder();
        border.setCenter(new Location(world, 0, 0, 0));
        border.setSize(150.0);
        for (int x = -5; x <= 5; ++x) {
            for (int z = -5; z <= 5; ++z) {
                world.setChunkForceLoaded(x, z, true);
            }
        }
        BukkitScheduler scheduler = getServer().getScheduler();
        scheduler.scheduleSyncRepeatingTask(this, () -> ticker.run(), 0, 1);
        PluginManager pluginManager = getServer().getPluginManager();
        pluginManager.registerEvents(this, this);
    }

    private Scoreboard makeDayScoreboard() {
        World world = getServer().getWorld("world");
        SimpleDateFormat format = new SimpleDateFormat("mm:ss");
        StatBoard board = StatBoard.builder()
                .withTitle("HoD Survival")
                .withSeparator()
                .withLine("Phase: " + ChatColor.AQUA + "Day")
                .withLine("Time: " + ChatColor.AQUA + format.format(new Date((long) (Math.ceil((13000 - world.getFullTime()) / 140.0) * 1000))))
                .build();
        return board.toScoreboard();
    }

    private Scoreboard makeNightScoreboard() {
        SimpleDateFormat format = new SimpleDateFormat("mm:ss");
        StatBoard board = StatBoard.builder()
                .withTitle("HoD Survival")
                .withSeparator()
                .withLine("Phase: " + ChatColor.AQUA + "Night")
                .withLine("Time: " + ChatColor.AQUA + format.format(new Date(roundTime / 20 * 1000)))
                .withLine("Remaining: " + ChatColor.AQUA + roundEntities.stream().filter(EntityLiving::isAlive).count())
                .build();
        return board.toScoreboard();
    }

    private void tickDay() {
        if (isVictory()) {
            return;
        }
        Scoreboard board = makeDayScoreboard();
        Bukkit.getOnlinePlayers().forEach(p -> p.setScoreboard(board));
        World world = getServer().getWorld("world");
        world.getPlayers().forEach(this::addDaytimeEffects);
        world.setFullTime(world.getFullTime() + 6);
        if (world.getFullTime() >= 13000) {
            world.getPlayers().forEach(this::removeDaytimeEffects);
            ticker = this::tickDayNight;
        }
    }

    private void addDaytimeEffects(Player player) {
        player.setWalkSpeed(0.5f);
    }

    private void removeDaytimeEffects(Player player) {
        player.setWalkSpeed(0.2f);
    }

    private void tickDayNight() {
        World world = getServer().getWorld("world");
        if (world.getFullTime() < 18000) {
            world.setFullTime(world.getFullTime() + 100);
            return;
        }
        Location spawnLocation = world.getSpawnLocation();
        if (!world.getPlayers().isEmpty()) {
            spawnLocation = world.getPlayers().get(0).getLocation();
        }
        roundTime = getCurrentWave().getTimeLimit();
        world.setFullTime(18000);
        world.setGameRule(GameRule.DO_DAYLIGHT_CYCLE, false);
        roundEntities.clear();
        for (String id : getCurrentWave().getUnits()) {
            roundEntities.add(genUnit(id, spawnLocation));
        }
        ticker = this::tickNight;
    }

    private void tickNightDay() {
        World world = getServer().getWorld("world");
        if (world.getFullTime() < 24000 && world.getFullTime() >= 13000) {
            world.setFullTime(world.getFullTime() + 200);
            return;
        }
        world.setFullTime(0);
        world.setGameRule(GameRule.DO_DAYLIGHT_CYCLE, true);
        ticker = this::tickDay;
    }

    private EntityLiving genUnit(String id, Location loc) {
        EntityLiving entity = null;
        CraftWorld world = (CraftWorld) loc.getWorld();
        if (id.equals("zergling")) {
            entity = new Zergling(world.getHandle());
        } else {
            entity = new Ultralisk(world.getHandle());
        }
        entity.setPosition(loc.getX(), loc.getY(), loc.getZ());
        world.getHandle().addEntity(entity);
        return entity;
    }

    private void tickNight() {
        World world = getServer().getWorld("world");
        Scoreboard board = makeNightScoreboard();
        Bukkit.getOnlinePlayers().forEach(p -> p.setScoreboard(board));
        if (roundTime <= 0) {
            for (Player player : world.getPlayers()) {
                player.damage(1);
            }
        }
        for (Player player : world.getPlayers()) {
            for (Entity e : player.getNearbyEntities(512, 256, 512)) {
                if (!(e instanceof Creature)) continue;
                Creature creature = (Creature) e;
                creature.setTarget(player);
            }
        }
        if (roundEntities.stream().allMatch(e -> !e.isAlive())) {
            roundIndex++;
            roundTime = 0;
            roundEntities.clear();
            ticker = this::tickNightDay;
        }
        roundTime = Math.max(0, roundTime - 1);
    }

    private Wave getCurrentWave() {
       return waves.get(roundIndex);
    }

    private boolean isVictory() {
        return roundIndex >= waves.size();
    }
}
